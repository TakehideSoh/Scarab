package jp.kobe_u.scarab

/**
 * `LogEncoder` is a class for translating CSP to SAT by log encoding.
 */
class LogEncoder(csp: CSP, satSolver: SatSolver) extends Encoder(csp, satSolver) {
  val simplifier = new Simplifier(this)

  private def log2(d: Int): Int = math.floor(math.log(d.toDouble) / math.log(2)).toInt + 1
  private def isPowerOf2Minus1(d: Int) = ((d + 1) & d) == 0

  // a1x1 + a2x2 + ... + anxn =< k
  // -a1x1 - a2x2 + ... -anxn >= -k
  // -a1(1-negx1) - a2(1-negx2) - ... - an(1-negxn) >= -k
  // -a1 + a1*negx1 - a2 + a2*negx2 - ... - an + an*negxn >= -k
  // a1*negx1 + a2*negx2 + ... + an*negxn >= -k + a1 + a2 + ... + an

  def normalizeCoef(as0: Seq[Int], xs0: Seq[Int], k0: Int): (Seq[Int], Seq[Int], Int) = {
    val as: Seq[Int] = as0.map(math.abs(_))
    val xs: Seq[Int] = for (i <- 0 until as0.size) yield if (as0(i) < 0) -1 * xs0(i) else xs0(i)
    val k = as0.filter(_ < 0).map(-_).sum + k0
    (as, xs, k)
  }

  def var2coefs(x: Var): Seq[Int] =
    (0 until log2(csp.dom(x).size - 1)).map(j => math.pow(2, j).toInt)

  def var2DimacsVars(x: Var): Seq[Int] =
    (this.code(x) until this.code(x) + log2(csp.dom(x).size - 1))

  // a1x1 + a2x2 + ... + anxn =< k
  // a1(b1 + 2*b2 + lb) + a2(b1 + 2*b2 + lb) =< k 
  // a1(b1 + 2*b2 + lb) + a2(b1 + 2*b2 + lb) =< k 
  // -a1(b1 + 2*b2 + lb) - a2(b1 + 2*b2 + lb) >= -k
  // -a1*b1 -2*a1*b2 -a1*lb -a1b1 -2a2b2 - a2lb >= -k
  // -a1*(1-negb1) -2*a1*(1-negb2) ... >= -k + a1*lb

  // a1*negx1 + a2*negx2 + ... + an*negxn >= -k + a1 + a2 + ... + an

  def addLeZeroAsNPB(lz: LeZero, c0: Seq[Int]): Seq[Seq[Int]] = {
    var vec0: Seq[Var] = lz.sum.coef.toSeq.map(xa => xa._1)

    var coef = vec0.flatMap(i => var2coefs(i).map(-1 * lz.sum.coef(i) * _))
    var b = lz.sum.b * -1 // in LHS

    var lbs = vec0.map(i => lz.sum.coef(i) * csp.dom(i).lb).sum
    var vec: Seq[Int] = vec0.flatMap(i => var2DimacsVars(i))

    val n = normalizeCoef(coef, vec, -b + lbs)
    coef = n._1
    vec = n._2
    var degree = n._3

    if (degree < 0) return Seq(FalseLit +: c0)

    val p = this.newBool
    vec = vec :+ code(p)
    coef = coef :+ degree

    satSolver.addPB(vec, coef, degree)

    Seq(-code(p) +: c0)
  }

  /** Returns the number of SAT variables required to encode `x`. */
  def satVariablesSize(x: Var): Int = log2(csp.dom(x).size - 1)

  /** Returns the list of clauses generated by encoding integer variable `x`. */
  def encode(x: Var): Seq[Seq[Int]] = {
    val dsize = csp.dom(x).size
    val nofBinaries = log2(dsize - 1)
    val code = this.code(x)
    val lb = csp.dom(x).lb

    // x
    // 2^0 * b0 + 2^1 * b1 + 2^2 * b2 + lb <= ub
    // 2^0 * b0 + 2^1 * b1 + 2^2 * b2 <= ub - lb

    if (!isPowerOf2Minus1(dsize - 1)) {
      //      println(nofBinaries)
      val as = (0 until nofBinaries).map(j => math.pow(2, j).toInt)
      val xs = (code until code + nofBinaries)
      val c = normalizeCoef(as.map(-_), xs, -(csp.dom(x).ub - lb))
      val a = c._2.toArray

      satSolver.addPB(c._2.toArray, c._1, c._3)

    }
    Seq.empty
  }

  /**
   * Returns the list of clauses generated by encoding literal `lit`.
   * `clause0` should be added to each clause generated.
   */
  def encode(lit: Literal, clause0: Seq[Int]): Seq[Seq[Int]] = lit match {
    case p: Bool    => Seq(code(p) +: clause0)
    case Not(p)     => Seq(-code(p) +: clause0)
    case lz: LeZero => addLeZeroAsNPB(lz, clause0)
    case _          => throw new Exception("OrderEncoder cannot accept EqZero and NeZero Literal.")
  }

  /** Adds the constraint to CSP after preprocessing and encodes it. */
  def add(c: Constraint): Unit = {
//    println(c)
    constIndex += 1
    constIndexMap += constIndex -> c
    for (lits <- simplifier.simplify(toLeZero(c)) if lits.size > 0) {
      if (lits.size == 1)
        csp.add(lits(0))
      else
        csp.add(Or(lits))

      val clauses = encode(lits)
      addAllClauses(clauses, constIndex)
    }
  }

  /**
   * Returns the sequence of literals that will be used as assumptions.
   */
  def extractAssumpLits(cs: Seq[Constraint]): Seq[Int] = {
    throw new Exception(s"Not yet implemented")
  }

  /** Returns the value of `x` from the satisfiable assignment found by the SAT solver. */
  def decode(x: Var): Int = {

    val nofBinaries = log2(csp.dom(x).size - 1)
    val code = this.code(x)
    val seq = for (i <- code until code + nofBinaries) yield if (satSolver.model(i)) math.pow(2, i - code).toInt else 0
    seq.sum + csp.dom(x).lb
  }

}